{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === \"undefined\" || o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } i = o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"](); return i.next.bind(i); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport queryString from 'query-string';\nexport default function getStateFromPath(path) {\n  var _ref;\n\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var initialRoutes = [];\n\n  var configs = (_ref = []).concat.apply(_ref, _toConsumableArray(Object.keys(options).map(function (key) {\n    return createNormalizedConfigs(key, options, [], initialRoutes);\n  })));\n\n  configs.sort(function (config1, config2) {\n    return config2.pattern.split('/').length - config1.pattern.split('/').length;\n  });\n  var remaining = path.replace(/[/]+/, '/').replace(/^\\//, '').replace(/\\?.*/, '');\n\n  if (remaining === '') {\n    var match = configs.find(function (config) {\n      return config.pattern === '' && config.routeNames.every(function (name) {\n        var _configs$find;\n\n        return !((_configs$find = configs.find(function (c) {\n          return c.screen === name;\n        })) === null || _configs$find === void 0 ? void 0 : _configs$find.pattern);\n      });\n    });\n\n    if (match) {\n      return createNestedStateObject(match.routeNames, initialRoutes, parseQueryParams(path, match.parse));\n    }\n\n    return undefined;\n  }\n\n  var result;\n  var current;\n\n  while (remaining) {\n    var routeNames = void 0;\n\n    var _params = void 0;\n\n    var _loop2 = function _loop2(config) {\n      if (!config.match) {\n        return \"continue\";\n      }\n\n      var didMatch = true;\n      var matchParts = config.match.split('/');\n      var remainingParts = remaining.split('/');\n\n      if (config.pattern.split('/').length > remainingParts.length) {\n        return \"continue\";\n      }\n\n      var paramsIndex = 0;\n\n      for (paramsIndex; paramsIndex < matchParts.length; paramsIndex++) {\n        if (matchParts[paramsIndex] !== remainingParts[paramsIndex]) {\n          didMatch = false;\n          break;\n        }\n      }\n\n      if (didMatch) {\n        routeNames = _toConsumableArray(config.routeNames);\n        var paramPatterns = config.pattern.split('/').filter(function (p) {\n          return p.startsWith(':');\n        });\n\n        if (paramPatterns.length) {\n          _params = paramPatterns.reduce(function (acc, p, i) {\n            var key = p.replace(/^:/, '');\n            var value = remainingParts[i + paramsIndex];\n            acc[key] = config.parse && config.parse[key] ? config.parse[key](value) : value;\n            return acc;\n          }, {});\n        }\n\n        if (config.pattern.split('/').length === remainingParts.length) {\n          remaining = '';\n        } else {\n          var i = config.pattern.split('/').length;\n\n          while (i--) {\n            remaining = remaining.substr(remaining.indexOf('/') + 1);\n          }\n        }\n\n        return \"break\";\n      }\n    };\n\n    _loop: for (var _iterator = _createForOfIteratorHelperLoose(configs), _step; !(_step = _iterator()).done;) {\n      var config = _step.value;\n\n      var _ret = _loop2(config);\n\n      switch (_ret) {\n        case \"continue\":\n          continue;\n\n        case \"break\":\n          break _loop;\n      }\n    }\n\n    if (routeNames === undefined) {\n      var segments = remaining.split('/');\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    var state = createNestedStateObject(routeNames, initialRoutes, _params);\n\n    if (current) {\n      var _current2;\n\n      while ((_current = current) === null || _current === void 0 ? void 0 : _current.routes[current.index || 0].state) {\n        var _current;\n\n        current = current.routes[current.index || 0].state;\n      }\n\n      current.routes[((_current2 = current) === null || _current2 === void 0 ? void 0 : _current2.index) || 0].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  var route = findFocusedRoute(current);\n  var params = parseQueryParams(path, findParseConfigForRoute(route.name, configs));\n\n  if (params) {\n    route.params = _objectSpread({}, route.params, {}, params);\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(key, routeConfig) {\n  var routeNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var initials = arguments.length > 3 ? arguments[3] : undefined;\n  var configs = [];\n  routeNames.push(key);\n  var value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    configs.push(createConfigItem(key, routeNames, value));\n  } else if (typeof value === 'object') {\n    if (typeof value.path === 'string') {\n      configs.push(createConfigItem(key, routeNames, value.path, value.parse));\n    }\n\n    if (value.screens) {\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens)\n        });\n      }\n\n      Object.keys(value.screens).forEach(function (nestedConfig) {\n        var result = createNormalizedConfigs(nestedConfig, value.screens, routeNames, initials);\n        configs.push.apply(configs, _toConsumableArray(result));\n      });\n    }\n  }\n\n  routeNames.pop();\n  return configs;\n}\n\nfunction createConfigItem(screen, routeNames, pattern, parse) {\n  var match = pattern !== '' ? pattern.split('/:')[0] : null;\n  return {\n    screen: screen,\n    match: match,\n    pattern: pattern,\n    routeNames: _toConsumableArray(routeNames),\n    parse: parse\n  };\n}\n\nfunction findParseConfigForRoute(routeName, flatConfig) {\n  for (var _iterator2 = _createForOfIteratorHelperLoose(flatConfig), _step2; !(_step2 = _iterator2()).done;) {\n    var config = _step2.value;\n\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n}\n\nfunction findInitialRoute(routeName, initialRoutes) {\n  for (var _iterator3 = _createForOfIteratorHelperLoose(initialRoutes), _step3; !(_step3 = _iterator3()).done;) {\n    var config = _step3.value;\n\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName ? undefined : config.initialRouteName;\n    }\n  }\n\n  return undefined;\n}\n\nfunction createStateObject(initialRoute, routeName, isEmpty, params) {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, _objectSpread({\n          name: routeName\n        }, params && {\n          params: params\n        })]\n      };\n    } else {\n      return {\n        routes: [_objectSpread({\n          name: routeName\n        }, params && {\n          params: params\n        })]\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, {\n          name: routeName,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    } else {\n      return {\n        routes: [{\n          name: routeName,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    }\n  }\n}\n\nfunction createNestedStateObject(routeNames, initialRoutes, params) {\n  var state;\n  var routeName = routeNames.shift();\n  var initialRoute = findInitialRoute(routeName, initialRoutes);\n  state = createStateObject(initialRoute, routeName, routeNames.length === 0, params);\n\n  if (routeNames.length > 0) {\n    var nestedState = state;\n\n    while (routeName = routeNames.shift()) {\n      initialRoute = findInitialRoute(routeName, initialRoutes);\n      nestedState.routes[nestedState.index || 0].state = createStateObject(initialRoute, routeName, routeNames.length === 0, params);\n\n      if (routeNames.length > 0) {\n        nestedState = nestedState.routes[nestedState.index || 0].state;\n      }\n    }\n  }\n\n  return state;\n}\n\nfunction findFocusedRoute(state) {\n  var _current4;\n\n  var current = state;\n\n  while ((_current3 = current) === null || _current3 === void 0 ? void 0 : _current3.routes[current.index || 0].state) {\n    var _current3;\n\n    current = current.routes[current.index || 0].state;\n  }\n\n  var route = current.routes[((_current4 = current) === null || _current4 === void 0 ? void 0 : _current4.index) || 0];\n  return route;\n}\n\nfunction parseQueryParams(path, parseConfig) {\n  var query = path.split('?')[1];\n  var params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach(function (name) {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n}","map":{"version":3,"sources":["getStateFromPath.tsx"],"names":["options","initialRoutes","configs","Object","key","createNormalizedConfigs","config2","config1","remaining","match","config","name","c","createNestedStateObject","parseQueryParams","routeNames","params","didMatch","matchParts","remainingParts","paramsIndex","paramPatterns","p","value","i","acc","segments","decodeURIComponent","state","current","result","route","findFocusedRoute","findParseConfigForRoute","routeConfig","createConfigItem","initials","initialRouteName","connectedRoutes","nestedConfig","pattern","screen","parse","routeName","index","routes","initialRoute","findInitialRoute","createStateObject","nestedState","query","path","queryString","parseConfig"],"mappings":"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","sourcesContent":["import queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  screen: string;\n  match: string | null;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  let initialRoutes: InitialRouteConfig[] = [];\n\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map((key) =>\n      createNormalizedConfigs(key, options, [], initialRoutes)\n    )\n  );\n\n  // sort configs so the most exhaustive is always first to be chosen\n  configs.sort(\n    (config1, config2) =>\n      config2.pattern.split('/').length - config1.pattern.split('/').length\n  );\n\n  let remaining = path\n    .replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*/, ''); // Remove query params which we will handle later\n\n  if (remaining === '') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find(\n      (config) =>\n        config.pattern === '' &&\n        config.routeNames.every(\n          // make sure that none of the parent configs have a non-empty path defined\n          (name) => !configs.find((c) => c.screen === name)?.pattern\n        )\n    );\n\n    if (match) {\n      return createNestedStateObject(\n        match.routeNames,\n        initialRoutes,\n        parseQueryParams(path, match.parse)\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let params: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      if (!config.match) {\n        continue;\n      }\n\n      let didMatch = true;\n      const matchParts = config.match.split('/');\n      const remainingParts = remaining.split('/');\n\n      // we check if remaining path has enough segments to be handled with this pattern\n      if (config.pattern.split('/').length > remainingParts.length) {\n        continue;\n      }\n\n      // we keep info about the index of segment on which the params start\n      let paramsIndex = 0;\n      // the beginning of the remaining path should be the same as the part of config before params\n      for (paramsIndex; paramsIndex < matchParts.length; paramsIndex++) {\n        if (matchParts[paramsIndex] !== remainingParts[paramsIndex]) {\n          didMatch = false;\n          break;\n        }\n      }\n\n      // If the first part of the path matches, we need to extract params from the path\n      if (didMatch) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '');\n            const value = remainingParts[i + paramsIndex]; // The param segments start from the end of matched part\n            acc[key] =\n              config.parse && config.parse[key]\n                ? config.parse[key](value)\n                : value;\n\n            return acc;\n          }, {});\n        }\n\n        // if pattern and remaining path have same amount of segments, there should be nothing left\n        if (config.pattern.split('/').length === remainingParts.length) {\n          remaining = '';\n        } else {\n          // For each segment of the pattern, remove one segment from remaining path\n          let i = config.pattern.split('/').length;\n          while (i--) {\n            remaining = remaining.substr(remaining.indexOf('/') + 1);\n          }\n        }\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    const state = createNestedStateObject(routeNames, initialRoutes, params);\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const route = findFocusedRoute(current);\n  const params = parseQueryParams(\n    path,\n    findParseConfigForRoute(route.name, configs)\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[]\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    configs.push(createConfigItem(key, routeNames, value));\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof value.path === 'string') {\n      configs.push(createConfigItem(key, routeNames, value.path, value.parse));\n    }\n\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens),\n        });\n      }\n      Object.keys(value.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          value.screens as Options,\n          routeNames,\n          initials\n        );\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  // part being matched ends on the first param\n  const match = pattern !== '' ? pattern.split('/:')[0] : null;\n\n  return {\n    screen,\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createStateObject(\n  initialRoute: string | undefined,\n  routeName: string,\n  isEmpty: boolean,\n  params?: Record<string, any> | undefined\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, ...(params && { params }) }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\n    }\n  }\n}\n\nfunction createNestedStateObject(\n  routeNames: string[],\n  initialRoutes: InitialRouteConfig[],\n  params: object | undefined\n) {\n  let state: InitialState;\n  let routeName = routeNames.shift() as string;\n  let initialRoute = findInitialRoute(routeName, initialRoutes);\n\n  state = createStateObject(\n    initialRoute,\n    routeName,\n    routeNames.length === 0,\n    params\n  );\n\n  if (routeNames.length > 0) {\n    let nestedState = state;\n\n    while ((routeName = routeNames.shift() as string)) {\n      initialRoute = findInitialRoute(routeName, initialRoutes);\n      nestedState.routes[nestedState.index || 0].state = createStateObject(\n        initialRoute,\n        routeName,\n        routeNames.length === 0,\n        params\n      );\n      if (routeNames.length > 0) {\n        nestedState = nestedState.routes[nestedState.index || 0]\n          .state as InitialState;\n      }\n    }\n  }\n\n  return state;\n}\n\nfunction findFocusedRoute(state: InitialState) {\n  let current: InitialState | undefined = state;\n\n  while (current?.routes[current.index || 0].state) {\n    // The query params apply to the deepest route\n    current = current.routes[current.index || 0].state;\n  }\n\n  const route = (current as PartialState<NavigationState>).routes[\n    current?.index || 0\n  ];\n\n  return route;\n}\n\nfunction parseQueryParams(\n  path: string,\n  parseConfig?: Record<string, (value: string) => any>\n) {\n  const query = path.split('?')[1];\n  const params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n}\n"]},"metadata":{},"sourceType":"module"}